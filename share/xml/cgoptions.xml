<tags>
  
  <item><name>cg</name><desc> Head option, which contains all coarse-graining options</desc></item>
  <item>
    <name>cg.non-bonded</name>
    <desc>
      Section for a non-bonded interaction. Most of the items in here are identical to items in cg.bonded,
      so they will be described in the same section.
    </desc>
  </item>
  <item>
    <name>cg.bonded</name>
    <desc>
      Section for a bonded interaction. Most of the items in here are identical to items in cg.bonded,
      so they will be described in the same section.
    </desc>
  </item>
  
  <item><name>cg.nbsearch</name><desc>Grid search algorithm, simple (N square search) or grid (default is grid)</desc></item>

<!-- general inverse options -->
  <item><name>cg.inverse</name><section/><desc>general options for inverse script</desc> </item>
  <item><name>cg.inverse.kBT</name><desc> kBT (300*0.00831451 gromacs units) </desc></item>
  <item><name>cg.inverse.program</name><desc>simulation package to be used</desc></item>
  <item><name>cg.inverse.initial_configuration</name><desc>what initial configuration to use in every step: maindir/laststep (default laststep) </desc></item>

  <item><name>cg.inverse.$sim_prog</name><desc> generic simulation program (e.g. GROMACS) options </desc></item>
  <item><name>cg.inverse.$sim_prog.equi_time</name><default>0.0</default><desc> begin analysis after this time </desc></item>
  <item><name>cg.inverse.$sim_prog.first_frame</name><default>0</default><desc> trash the given number of frames at the beginning of trajectory</desc></item>


  <item><name>cg.inverse.gromacs</name><desc> gromacs specific options </desc></item>
  <item><name>cg.inverse.gromacs.conf</name><desc>Name of the coordinate file read by grompp (default conf.gro)</desc></item>
  <item><name>cg.inverse.gromacs.conf_out</name><desc>Name of the original outcome coordinate written by mdrun (default confout.gro)</desc></item>
  <item><name>cg.inverse.gromacs.gmxrc</name><desc>GMXRC to source at the startup</desc></item>
  <item><name>cg.inverse.gromacs.equi_time</name><default>0.0</default><desc> begin analysis after this time when using gromacs</desc></item>
  <item><name>cg.inverse.gromacs.first_frame</name><default>0</default><desc> trash the given number of frames at the beginning of trajectory</desc></item>
  <item><name>cg.inverse.gromacs.topol</name><desc> binary Gromacs topology file to use, default topol.tpr</desc></item>
  <item><name>cg.inverse.gromacs.traj_type</name><desc> Gromacs trajectory type (xtc/trr) file to use, default xtc</desc></item>
  <item><name>cg.inverse.gromacs.mdp</name><desc> Gromacs mdp fie to use, default grompp.mdp</desc></item>
  <item><name>cg.inverse.gromacs.grompp.index</name><desc> Gromacs grompp index file to use, default index.ndx</desc></item>
  <item><name>cg.inverse.gromacs.grompp.topol</name><desc> Text Gromacs toplogy file to use, default topol.top</desc></item>
  <item><name>cg.inverse.gromacs.grompp.bin</name><desc> Name (or absolute path) of the grompp binary</desc></item>
  <item><name>cg.inverse.gromacs.grompp.opts</name><desc> Additional options to Gromacs grompp (e.g. -maxwarn 1)</desc></item>
  <item><name>cg.inverse.gromacs.g_rdf.index</name><desc> Gromacs g_rdf index file to use, default index.ndx</desc></item>
  <item><name>cg.inverse.gromacs.g_rdf.topol</name><desc> Gromacs g_rdf topol file to use, default topol.tpr</desc></item>
  <item><name>cg.inverse.gromacs.g_rdf.bin</name><desc> Name (or absolute path) of the g_rdf binary</desc></item>
  <item><name>cg.inverse.gromacs.g_rdf.opts</name><desc> Additional options for Gromacs g_rdf (e.g. -nopbc)</desc></item>
  <item><name>cg.inverse.gromacs.mdrun.command</name><desc>Command to run mdrun (name or absolute path or mpirun mdrun..)</desc></item>
  <item><name>cg.inverse.gromacs.mdrun.opts</name><desc> Additional options to Gromacs mdrun (e.g. -nosum)</desc></item>
  <item><name>cg.inverse.gromacs.mdrun.checkpoint</name><desc>Name of the checkpint to use in case of restarted simulation (default state.cpt)</desc></item>
  <item><name>cg.inverse.gromacs.g_energy.topol</name><desc> Gromacs g_rdf topol file to use, default topol.tpr</desc></item>
  <item><name>cg.inverse.gromacs.g_energy.bin</name><desc> Name (or absolute path) of the g_energy binary</desc></item>
  <item><name>cg.inverse.gromacs.g_energy.opts</name><desc> Additional options to Gromacs g_rdf (e.g. -P 1)</desc></item>
  <item><name>cg.inverse.gromacs.table_bins</name><desc> grid for table*.xvg !</desc></item>
  <item><name>cg.inverse.gromacs.pot_max</name><desc> cut the potential at this value (gromacs bug) </desc></item>
  <item><name>cg.inverse.gromacs.table_end</name><desc> extend the tables to this value </desc></item>
  <item><name>cg.inverse.gromacs.cutoff_check</name><desc> check interaction cutoffs against rvdw in mdp file: yes/no (default yes)</desc></item>
  <item><name>cg.inverse.gromacs.temp_check</name><desc> check temperture against t_ref in mdp file: yes/no (default yes)</desc></item>
  <item><name>cg.inverse.gromacs.rdf.topol</name><desc> Gromacs topol file to be used for csg_stat default topol.tpr</desc></item>
  <item><name>cg.inverse.espresso.blockfile</name><desc>Name of the original blockfile read by Espresso (default conf.esp.gz)</desc></item>
  <item><name>cg.inverse.espresso.blockfile_out</name><desc>Name of the original outcome blockfile written by Espresso (default confout.esp.gz)</desc></item>
  <item><name>cg.inverse.espresso.command</name><desc>Command to run espresso (name or absolute path or mpirun espresso..)</desc></item>
  <item><name>cg.inverse.espresso.rdf_command</name><desc>Espresso command to run when calculating the rdf (name or absolute path or mpirun espresso..)</desc></item>
  <item><name>cg.inverse.espresso.pressure_command</name><desc>Espresso command to run when calculating the pressure (name or absolute path or mpirun espresso..)</desc></item>
  <item><name>cg.inverse.espresso.first_frame</name><desc>rash the given number of frames at the beginning of trajectory</desc></item>
  <item><name>cg.inverse.espresso.table_bins</name><desc> grid for tabulated potentials </desc></item>
  <item><name>cg.inverse.espresso.traj</name><desc> Name of the output Espresso trajectory file</desc></item>
  <item><name>cg.inverse.espresso.n_steps</name><desc> number of steps to integrate before a snapshot</desc></item>
  <item><name>cg.inverse.espresso.n_snapshots</name><desc> number of snapshots. Total time = n_steps * n_snapshots</desc></item>
  <item><name>cg.inverse.espresso.debug</name><desc> debug Espresso (yes/no)</desc></item>
  <item><name>cg.inverse.espresso.table_end</name><desc> Espresso end of table</desc></item>
  <item><name>cg.inverse.espresso.exclusions</name><desc> Espresso stuff to exclude</desc></item>
  <item><name>cg.inverse.espresso.meta_cmd</name><desc> Espresso metadynamics command to call [experimental]</desc></item>
  <item><name>cg.inverse.espresso.success</name><desc> File to create if Espresso simulation was successfull</desc></item>
  <item><name>cg.inverse.espresso.meta_min_sampling</name><desc> Espresso metadynamics minimal number of sampling [experimental]</desc></item>
  <item><name>cg.inverse.espresso.scriptdir</name><desc>overwrite ESPRESSO_SCRIPTS from environment with this dir</desc></item>
  <item><name>cg.inverse.filelist</name><desc> these files are copied for each new run </desc></item>
  <item><name>cg.inverse.cleanlist</name><desc> these files are removed after each new run </desc></item>
  <item><name>cg.inverse.iterations_max</name><desc> do the given number of iterations (0=inf) </desc></item>
  <item><name>cg.inverse.convergence_check</name><desc>type of convergence check to do</desc></item>
  <item><name>cg.inverse.convergence_check_options</name><desc>options for the convergence check</desc></item>
  <item><name>cg.inverse.convergence_check_options.limit</name><desc>lower limit to stop</desc></item>
  <item><name>cg.inverse.convergence_check_options.name_glob</name><desc>files to check for number (default *.conv)</desc></item>
  <item><name>cg.inverse.method</name><desc> ibi: inverse boltzmann imc: inverse monte carlo </desc></item>
  <item><name>cg.inverse.scriptdir</name><desc> directory for user scripts (e.g. $PWD)</desc></item>
  <item><name>cg.inverse.log_file</name><desc> write log to this file </desc></item>
  <item><name>cg.inverse.simulation</name><desc>simulation options </desc></item>
  <item><name>cg.inverse.simulation.tasks</name><desc>number of tasks (0/auto = automatic detect on linux)</desc></item>
  <item><name>cg.inverse.simulation.background</name><desc>tell csg_inverse that  simulation was send to the backgroud (default no)</desc></item>
  <item>
    <name>cg.inverse.restart_file</name>
    <desc>
      Name of the restart file in case a step has to be resumed
    </desc>
  </item>
  <item><name>cg.inverse.imc</name><desc> general imc specific options </desc></item>
  <item><name>cg.inverse.imc.solver</name><desc> solver for solving a linear equation system, can be octave or matlab </desc></item>
  <item><name>cg.inverse.imc.octave.bin</name><desc> Name (or absolute path) of the octave binary </desc></item>
  <item><name>cg.inverse.imc.numpy.bin</name><desc> Name (or absolute path) of the python binary used by the numpy solver</desc></item>
  <item><name>cg.inverse.imc.matlab.bin</name><desc> Name (or absolute path) of the matlab binary </desc></item>
  
  
  <!-- force matching stuff -->
  <item>
    <name>cg.fmatch</name>
    <desc>
      Force matching options
    </desc>
  </item>

  <item>
    <name>cg.fmatch.frames_per_block</name>
    <desc>
      number of frames, being used for block averaging. Atomistic trajectory, specified with
       --trj option, is divided into blocks and the force matching equations are solved separately for each block.
      Coarse-grained force-field, which one gets on the output is averaged over those blocks.
    </desc>
  </item>
    
  <item>
    <name>cg.fmatch.constrainedLS</name>
    <desc>
      boolean variable: false - simple least squares, true - constrained least squares.
      For details see the VOTCA paper. Practically, both algorithms give the same results,
      but simple least squares is faster. If you are a mathematician and you think that a spline
      can only then be called a spline if it has continuous first and second derivatives,
      use constrained least squares.
    </desc>
  </item>
</tags>
